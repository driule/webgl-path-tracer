"use strict";
// namespace LH {
Object.defineProperty(exports, "__esModule", { value: true });
var GLUtilities_1 = require("./gl/GLUtilities");
var GLBuffer_1 = require("./gl/GLBuffer");
var Shader_1 = require("./gl/Shader");
var GLBuffer_2 = require("./gl/GLBuffer");
var app_1 = require("./app");
var PathTracer = /** @class */ (function () {
    function PathTracer(canvas) {
        this._canvas = canvas;
        // create framebuffer
        this._framebuffer = GLUtilities_1.gl.createFramebuffer();
        // create textures
        var type = GLUtilities_1.gl.getExtension('OES_texture_float') ? GLUtilities_1.gl.FLOAT : GLUtilities_1.gl.UNSIGNED_BYTE;
        this._textures = [];
        for (var i = 0; i < 2; i++) {
            this._textures.push(GLUtilities_1.gl.createTexture());
            GLUtilities_1.gl.bindTexture(GLUtilities_1.gl.TEXTURE_2D, this._textures[i]);
            GLUtilities_1.gl.texParameteri(GLUtilities_1.gl.TEXTURE_2D, GLUtilities_1.gl.TEXTURE_MIN_FILTER, GLUtilities_1.gl.NEAREST);
            GLUtilities_1.gl.texParameteri(GLUtilities_1.gl.TEXTURE_2D, GLUtilities_1.gl.TEXTURE_MAG_FILTER, GLUtilities_1.gl.NEAREST);
            GLUtilities_1.gl.texParameterf(GLUtilities_1.gl.TEXTURE_2D, GLUtilities_1.gl.TEXTURE_WRAP_S, GLUtilities_1.gl.CLAMP_TO_EDGE);
            GLUtilities_1.gl.texParameterf(GLUtilities_1.gl.TEXTURE_2D, GLUtilities_1.gl.TEXTURE_WRAP_T, GLUtilities_1.gl.CLAMP_TO_EDGE);
            GLUtilities_1.gl.texImage2D(GLUtilities_1.gl.TEXTURE_2D, 0, GLUtilities_1.gl.RGB, this._canvas.width, this._canvas.height, 0, GLUtilities_1.gl.RGB, type, null);
        }
        GLUtilities_1.gl.bindTexture(GLUtilities_1.gl.TEXTURE_2D, null);
        // create shaders
        this._tracerShader = new Shader_1.Shader('tracer', app_1.loadFile('shaders/tracer.vertex.glsl'), app_1.loadFile('shaders/tracer.fragment.glsl'));
        this._renderShader = new Shader_1.Shader('render', app_1.loadFile('shaders/render.vertex.glsl'), app_1.loadFile('shaders/render.fragment.glsl'));
        var renderVertexAttribute = new GLBuffer_2.AttributeInformation();
        renderVertexAttribute.location = this._renderShader.getAttributeLocation('vertex');
        renderVertexAttribute.offset = 0;
        renderVertexAttribute.size = 2;
        this._vertexBuffer = new GLBuffer_1.GLBuffer(2, GLUtilities_1.gl.FLOAT, GLUtilities_1.gl.ARRAY_BUFFER, GLUtilities_1.gl.TRIANGLE_STRIP);
        this._vertexBuffer.pushBackData([
            -1, -1,
            -1, +1,
            +1, -1,
            +1, +1
        ]);
        this._vertexBuffer.addAttributeLocation(renderVertexAttribute);
    }
    PathTracer.prototype.update = function (timeSinceStart) {
        // calculate uniforms
        var uniforms = {};
        uniforms.resolution = [this._canvas.width, this._canvas.height];
        uniforms.eye = this._scene.camera.eye;
        uniforms.ray00 = this._scene.camera.getEyeRay(-1, -1);
        uniforms.ray01 = this._scene.camera.getEyeRay(-1, +1);
        uniforms.ray10 = this._scene.camera.getEyeRay(+1, -1);
        uniforms.ray11 = this._scene.camera.getEyeRay(+1, +1);
        uniforms.timeSinceStart = timeSinceStart;
        uniforms.textureWeight = this._sampleCount / (this._sampleCount + 1);
        // triangle data
        uniforms.triangles = this._scene.triangles;
        uniforms.totalTriangles = this._scene.triangles.length;
        uniforms.triangleDataTextureSize = Math.ceil(Math.sqrt(this._scene.triangles.length * 3));
        // BVH data
        uniforms.bvhNodeList = this._scene.bvh.nodeStack;
        uniforms.totalBvhNodes = uniforms.bvhNodeList.length;
        // {min}, {max}, {isLeaf, first, count}, {left, right, 0} - 4 rgb units
        uniforms.bvhDataTextureSize = Math.ceil(Math.sqrt(this._scene.bvh.nodeStack.length * 4));
        uniforms.triangleIndices = this._scene.bvh.triangleIndices;
        uniforms.triangleIndicesDataTextureSize = Math.ceil(Math.sqrt(uniforms.triangleIndices.length));
        // light data
        uniforms.lights = this._scene.lights;
        uniforms.totalLights = this._scene.lights.length;
        uniforms.lightDataTextureSize = Math.ceil(Math.sqrt(this._scene.lights.length * 2));
        // set uniforms
        this._tracerShader.use();
        // render to texture
        GLUtilities_1.gl.activeTexture(GLUtilities_1.gl.TEXTURE0);
        GLUtilities_1.gl.bindTexture(GLUtilities_1.gl.TEXTURE_2D, this._textures[0]);
        GLUtilities_1.gl.bindFramebuffer(GLUtilities_1.gl.FRAMEBUFFER, this._framebuffer);
        GLUtilities_1.gl.framebufferTexture2D(GLUtilities_1.gl.FRAMEBUFFER, GLUtilities_1.gl.COLOR_ATTACHMENT0, GLUtilities_1.gl.TEXTURE_2D, this._textures[1], 0);
        this._tracerShader.setUniforms(uniforms);
        this._vertexBuffer.upload();
        this._vertexBuffer.draw();
        // ping pong textures
        this._textures.reverse();
        this._sampleCount++;
    };
    PathTracer.prototype.render = function () {
        this._renderShader.use();
        GLUtilities_1.gl.bindFramebuffer(GLUtilities_1.gl.FRAMEBUFFER, null);
        GLUtilities_1.gl.bindTexture(GLUtilities_1.gl.TEXTURE_2D, this._textures[0]);
        this._vertexBuffer.draw();
    };
    PathTracer.prototype.setScene = function (scene) {
        this._scene = scene;
        this.restart();
    };
    PathTracer.prototype.restart = function () {
        this._sampleCount = 0;
    };
    return PathTracer;
}());
exports.PathTracer = PathTracer;
// }
//# sourceMappingURL=PathTracer.js.map